/*
node.js 는 v8자바스크립트 엔진과 libuv 및 C/C++에 의존성을 가진 자바스크립트 런타입입니다
(런타임 : 자바스크립트로 된 프로그램을 실행할 수 잇는 프로그램)

1.node.js의 구성요소
[1] node.js API
자바스크립트 api
[2] node.js 바인딩
자바스크립트에서 c/c++ 함수를 호출할 수 있게 해준다
[3] node.js 표준라이브러리
운영체제와 관련된 함수들, 타이머, 파일시스템, 네트워크 요청
[4] C/C++ 에드온
node.js에서 c/c++ 소스를 실행할 수 있게 하는 애드온
[5] V8(C++)
오픈 소스 자바스크립트 엔진. 자바스크립트를 파싱, 인터프리터, 컴파일, 최적화에 사용
[6] libuv(C++)
비동기 I/O에 초점을 맞춘 멀티플랫폼을 지원하는 라이브러리, 이벤트루프,스레드풀 등을 사용ㅎ
[7] 기타 C/C++ 컴포넌트
http 파서, openssl, zlib등에 사용

사용자의 코드는 node.js api를 사용하고. node.js api는 c++에 바인딩 되어 있는 소스이거나 직접 만든 c++애드온을 호출한다.
c++에서는 v8을 사용해 자바스크립트를 해석 및 최적화하고 어떤 코드냐에 따라 c/c++ 종속성이 있는 코드를 실행
또한 dns, http 파서, openssl 이외의 c/c++ 코드들은 libuv의 api를 사용하여 운영체제에 맞는 api를 실행

(1)v8엔진
c++로 만든 오픈 소스 자바스크립트 엔진
(엔진 : 사용자가 작성한 코드를 실행하는 프로그램)
엔진은 파서, 컴파일러, 인터프리터, 가비지 컬랙터, 콜스택, 힙으로 구성되어 있습니다.
(
파서 : 텍스트를 특정한 의미 규칙에 따라 구조화 하는 것 파서에 들어간 코드는 트리구조를 갖는다
인터프리터 : 프로그램이 실행할 때부터 코드를 읽어서 기계가 이해할 수 있게 코드를 변환하는 것 
컴파일러 :  프로그램이 실행될 때 코드를 이미 다 읽어서 기계어로 변환한 것 
가비지컬랙터 : 메모리 누수를 방지하기 위해 주기적으로 사용하지 않는 메모리 공간을 회수하는 기능
콜스택 : 현재 실행 중인 서브루틴에 관한 정보를 저장하는 스택
힙 : 객체나 동적 데이터가 저장되는 메모리 공간
)
자바스크립트 코드의 컴파일 단계
1.코드가 파서에 전달되어 추상구문 트리로 만들어진다.
2.이스니션 인터프리터에 전달된후 바이트 코드로 만들어진다.
  최적화가 필요할 경우이면 터보팬에 넘겨지며, 컴파일 과정을 거쳐서 바이너리 코드가 된다
  최적화가 잘되지 않은 경우엔 최적화를 해제하고 이그니션의 인터프리터 기능을 사용

이처럼 인터프리터와 컴파일러의 장점을 동시에 가지고 있는 프로그램을 JIT(just-in-time)컴파일러라고 한다.
jit는 속도가 빠르며, 적재적소에 최적화를 할 수 있다는 장점이 있지만 
컴파일러와 인터프리터가 동시에 실행되어 메모리를 많이 쓴다는 단점이 있다

(2)libuv
이벤트 루프와 운영체제 단 비동기 API 및 스레드 풀을 지원
http, openssl등을 지원해준다.

node 애플리케이션에서 코드가 실행되는 과정
1.애플리케이션에서 들어온 요청을 v8엔진이 자바스크립트 코드를 바이트코드나 기계어로 변경
2.v8엔진은 이벤트 루프인 libuv로 요청을 전달한 후 libuv 내부의 이벤트 큐에 추가
3.이벤트 큐에 쌓은 요청은 이벤트 루프에 전달되고, 운영체제 커널에 비동기 처리를 맡김
  운영체제 내부적으로 비동기 처리가 어려운 경우 워커 스레드에서 처리
4.운영체제 커널 또는 워커 스레드가 완료한 작업을 다시 이벤트 루프로 전달
5.이벤트 루프에서 콜백으로 전달된 요청에 대한 완료 처리를 하고 넘김
6.완료 처리된 응답을 v8에서 자바스크립트로 변경하여 node.js 애플리케이션으로 넘김



2.node.js의 기술적인 특징
2.1.싱글스레드
한 번에 하나의 작업만 가능하다.
콜스택은 코드의 명령어들이 저장되는 곳.
스택방식으로 가장나중에 들어온 것이 가장먼저 나간다.

2.2 이벤트 기반 아키택쳐
한번에 100개의 요청이 왔고 처리하는데 1초가 걸리면 제일 마지막에 요청한 사람은 100초 뒤에 응답을 받을 수 있다.
멀티 스레드를 지원하는 언어라면 스레드를 100개 만들어서 처리하면 되지만 node는 싱글스레드 이므로 그렇게 할 수 없다.
이에 대한 해결 방법은 이벤트 기반 아키텍쳐를 적용하는 것입니다
콜스택에 쌓인 작업을 다른 곳에서 처리한 다음 처리가 완료되었을 때 알림을 받으면 스레드가 하나라도 빠르게 처리할 수 있다.
예를 들어
커피숍카운터에서 손님이 주문을 할 때 손님에게 진동벨을 주고 다음 손님의 주문을 받는다.
손님은 진동벨이 울리면 커피를 찾으러간다.
이 때 줄을 섰던 순서와는 다르게 빠르게 제조된 음료가 먼저 나올 수도 있다.

자바스크립트 코드는 v8의 콜스택에 쌓이고 i/o처리가 필요한 코드는 이벤트 루프에 보내게 됩니다.
이벤트 루프에서는 루프를 실행하면서 운영체제 및 스레드 워커에 i/o처리를 맡깁니다.
스레드 워커와 운영체제는 받은 요청에 대한 결과를 이벤트 루프에 돌려주고 이벤트 루프는 결과값에 대한 코드를 콜스택에 다시 추가합니다.
작업하는데 시간이 오래걸리는 것을 이벤트 루프에 맡겨서 처리한다.
node의 프로세스는 이벤트 루프에서 사용하는 싱글 스레드 하나와 비동기 처리를 지원하는 스레드 풀로 구성되어 있다.

2.3.이벤트 루프
node에서는 이벤트 기반 아키텍쳐를 구축하는 데 반응자 패턴을 사용하였습니다
반응자 패턴이란 이벤트 디멀티플렉서와 이벤트 큐로 구성되어 있습니다.
반응자 패턴은 이벤트를 추가하는 주체와 해당 이벤트를 실행하는 주체를 분리하는 구조 입니다.

이벤트 루프는 여러 개의 fifo큐로 이루어져 있습니다
각 단계를 돌면서 각 큐에 쌓인 이벤트를 모두 처리 합니다.
이벤트 루프에서 시작 및 각 반복의 마지막에 루프가 활성화 상태인지 체크 합ㄴ디ㅏ.
타이머 단계에서는 타이머 큐를 처리하며 setTimeout, setInteval등을 여기서 처리합니다.
펜딩I/O 콜백 단계에서는 다음 반복으로 연기된 콜백을 처리합니다
유휴,내부 단계는 내부적으로만 사용됩니다
poll단계에서는 새로운 연결(소켓)을 맺고, 파일 읽기 등의 작업을 합니다.
각 작업은 비동기 i/o를 사용하거나 스레드 풀을 사용합니다.
검사단계에서는 setImmediate를 처리합니다
종료 콜백 단계에서는 콜백의 종료처리를 합니다.
여기서 nextTickQueue와 microTaskQueues는 조금 특별한 장치입니다.
위의 각단계의 사이마다 nextTickQueue와 microTaskQueue에 있는 작업을 먼저 실행하기 때문입니다.
process.nextTick()함수로 nextTickQueue에 작업을 추가할 수 있습니다
microTaskQuere에는 promise로 만든 콜백 함수가 추가 됩니다.
nextTickQueue가 microTaskQueue보다 우선순위가 높습니다. 

*/
